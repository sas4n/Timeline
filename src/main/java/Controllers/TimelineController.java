package Controllers;

import Models.Event;
import Models.Timeline;
import Utils.EventThumbnail;
import javafx.concurrent.Task;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.geometry.HPos;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.geometry.VPos;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.layout.*;
import javafx.scene.paint.Color;
import javafx.scene.shape.Line;
import javafx.stage.Modality;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import main.Main;
//import main.Settings; // just putted this line in the comment cause it causes a bug and it was avoiding us to run the program.

import java.net.URL;
import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.*;
import java.util.stream.Collectors;
import java.util.ArrayList;

public class TimelineController implements Initializable {

    //SCALES DEFINITION

    Timeline timeline;
    private MainController parentController;

    public boolean isEditMode() {
        return editMode;
    }

    public void setEditMode(boolean editMode) {
        this.editMode = editMode;
    }

    private boolean editMode = false;

    private boolean busy = false; //when loading events make it busy
    private String unitLeft = ""; //fixed unit/label on the left
    private String unitRight = ""; //fixed unit/label on the right
    private String timelineType = "absolute"; //absolute or relative
    private String scale = ""; //day (with hours and minutes); month (with days); year (with months); decade (with years)
    private double timelinePageWidth = 2000.0; //We defined the width of a page, it cannot be less than 250
    //create 4 pages of the background => each page have the representation of the selected scale
    GridPane[] rulerPages = new GridPane[4];
    int currentPageNumber = 0;
    Calendar startTimelineDate;
    double offSetStartingTimeGUI = 0.0;

    int previousCurrentPageNumber = 0;
    boolean generatingBackground = false;

    int startTimelineInt = 0;
    int endTimelineInt = 0;
    int stepTimelineInt = 0;
    final int intPerPage = 30;
    final int intPageWidth = 2000;

    double timeRatio = 0.0; //to convert seconds in pixels

    double lenght24hours = 2000.0;
    int pageTimeUnit = Calendar.DAY_OF_MONTH;
    double previousScrollPos = 0; //to get the direction of scroll
    long timelineStartSeconds = 0L;
    int lastPageLoadedEvents = 0;
    Thread eventsLoaderThread;
    private double viewportWidth = 1000; //width of the part of the scrollPane that the user views
    private double timelineWidth = 2000; //autogenerated

    //WIDTH BETWEEN markers
    double spaceBetweenMarkers = 0.0;

    //we have 8 vertical slots we can use
    //the position of the right side of an event thumbnail => this is used when the user scrolls to the right
    private double[] occupiedEventSlots_rightEdge = new double[8];
    //the position of the left side of an event thumbnail => this is used when the user scrolls to the left
    private double[] occupiedEventSlots_leftEdge = new double[8];

    //FOR DEGUB ONLY
    //Long totalNumberEvents = 0L;

    private List<EventThumbnail> activeEventThumbnails = new ArrayList<>(); //store events that are in display

    @FXML
    private StackPane TimelineContainer;

    @FXML
    private HBox timelineBackgroundHolder;

    @FXML
    private Region leftSpacer;

    public void setViewportWidth(double width) {
        //System.out.println("=== VIEWPORT WIDTH: "+width);
        viewportWidth = width;
    }

    public void setTimeline(Timeline timeline) {
        //reset previous timeline
        if (rulerPages.length > 0 && rulerPages[0] != null) {
            timelineBackgroundHolder.getChildren().removeAll(rulerPages);
        }
        TimelineContainer.getChildren().removeAll(activeEventThumbnails.stream().map(t -> t.getView()).collect(Collectors.toList()));
        occupiedEventSlots_rightEdge = new double[8];
        occupiedEventSlots_leftEdge = new double[8];
        activeEventThumbnails = new ArrayList<>();
        currentPageNumber = 0;
        offSetStartingTimeGUI = 0.0;
        timeRatio = 0.0;
        previousScrollPos = 0;
        leftSpacer.setMaxWidth(0);
        leftSpacer.setMinWidth(0);
        leftSpacer.setPrefWidth(0);
        lenght24hours = 0.0;
        startTimelineInt = 0;
        endTimelineInt = 0;
        stepTimelineInt = 0;
        timelineType = "absolute";

        //reset minimum width of the timeline
        minTimelineWidth = 0;
        timelineBackgroundHolder.setMinWidth(0);

        //END RESET

        this.timeline = timeline;

        if (timeline.getStartDate() != null) {
            //generate first pages
            startTimelineDate = GregorianCalendar.getInstance(); // creates a new calendar instance
            startTimelineDate.setTime(timeline.getStartDate());
            //Make it start at midnight
            startTimelineDate.set(Calendar.HOUR_OF_DAY, 0);
            startTimelineDate.set(Calendar.MINUTE, 0);
            startTimelineDate.set(Calendar.SECOND, 0);

            timelineStartSeconds = startTimelineDate.toInstant().getEpochSecond();// .getTimeInMillis() / 1000L;
        }

        //scale = "hour";
        if (timeline.getTimeUnit().equals("hour") || timeline.getTimeUnit().equals("Hours")) {
            //scale = timeline.getTimeUnit();
            lenght24hours = 2000.0;
            //TODO: adjust
            offSetStartingTimeGUI = (lenght24hours / 48) + ((lenght24hours / 48) / 2);  ///  * 3; //00:00 starts at this point
            //timelinePageWidth (4344.0) ===> 24hours (86400 seconds)
            //20.83333 => margin right for each page
            //timeRatio = (timelinePageWidth + 20.83333) / 86400.0;
        } else if (timeline.getTimeUnit().equals("day") || timeline.getTimeUnit().equals("Days")) {
            //Scale day (each page is one month)
            //timeRatio = (timelinePageWidth + 20.83333) / 2592000;
            //TODO: PROBLEM?
            lenght24hours = 150.0;
            //TODO: adjust
            offSetStartingTimeGUI = 130;
        } else if (timeline.getTimeUnit().equals("month") || timeline.getTimeUnit().equals("Months")) {
            //Scale months (each page is one year)
            //timeRatio = (timelinePageWidth + 20.83333) / 31556952;
            lenght24hours = 5.0;
            //TODO: adjust
            offSetStartingTimeGUI = 0;
        } else if (timeline.getTimeUnit().equals("year") || timeline.getTimeUnit().equals("Years") || timeline.getTimeUnit().equals("decade") || timeline.getTimeUnit().equals("Decades") || timeline.getTimeUnit().equals("century") || timeline.getTimeUnit().equals("Centuries")) {
            timelineType = "semi";
            Calendar from = new GregorianCalendar(), to = new GregorianCalendar();
            from.setTime(timeline.getStartDate());
            to.setTime(timeline.getEndDate());
            startTimelineInt = from.get(Calendar.YEAR);
            endTimelineInt = to.get(Calendar.YEAR);
            //TODO: start in a decade or century
            offSetStartingTimeGUI = 50;
            parentController.setTimeLabelRight("Years");
        } else if (timeline.getTimeUnit().equals("minute") || timeline.getTimeUnit().equals("Minutes")) {
            timelineType = "semi";
            startTimelineInt = 0;
            endTimelineInt = ((int) (timeline.getEndDate().toInstant().getEpochSecond() - timeline.getStartDate().toInstant().getEpochSecond()) / 60);
            offSetStartingTimeGUI = 50;
            parentController.setTimeLabelRight("Minutes");
        } else if (timeline.getTimeUnit().equals("second") || timeline.getTimeUnit().equals("Seconds")) {
            timelineType = "semi";
            startTimelineInt = 0;
            endTimelineInt = ((int) (timeline.getEndDate().toInstant().getEpochSecond() - timeline.getStartDate().toInstant().getEpochSecond()));
            offSetStartingTimeGUI = 50;
            parentController.setTimeLabelRight("Seconds");
        } else {
            timelineType = "relative";
            offSetStartingTimeGUI = 50;
            parentController.setTimeLabelRight(timeline.getTimeUnit());
        }

        // MUST BE THE SAME AS CREATE BACKGROUND
        pageTimeUnit = getCalendarTimeUnit(lenght24hours);

        System.err.println("timeRatio: " + timeRatio);

        updateEdgeLabels(0);

        //Generate the only 4 pages we will need
        for (int i = 0; i < 4; i++) {
            rulerPages[i] = createTimelineBackgroundPage(null, i);
        }

        timelineBackgroundHolder.getChildren().addAll(rulerPages);

        //get the first 4 days events
        loadEvents(0, ScrollDirection.NONE);
    }

    private int calculateCurrentPage(double scrolledLength) {
        if (timelineType.equals("absolute") == false) {
            return (int) (Math.abs(scrolledLength - offSetStartingTimeGUI) / intPageWidth);
        } else {
            double numbDaysScrolled = scrolledLength / lenght24hours;
            if (pageTimeUnit == Calendar.DAY_OF_MONTH) {
                //Each page is a day
                return (int) numbDaysScrolled;
            } else if (pageTimeUnit == Calendar.WEEK_OF_MONTH) {
                return (int) numbDaysScrolled / 7;
            } else if (pageTimeUnit == Calendar.MONTH) {
                //TODO: EACH MONTH HAVE DIFFERENT NUMBER OF DAYS!!!
                //System.err.println("ERROR CALCULATING ELAPSED PAGES");
                return (int) (numbDaysScrolled / 30.4375);
            } else if (pageTimeUnit == Calendar.YEAR) {
                //System.err.println("ERROR CALCULATING ELAPSED PAGES");
                return (int) (numbDaysScrolled / 365.25);
            } else {
                System.err.println("ERROR PAGE: NOT IMPLEMENTED");
                return (int) numbDaysScrolled;
            }
        }
        //return (int) (Math.abs(scrolledLength - offSetStartingTimeGUI) / lenght24hours);
    }

    public void timelineScroll(double timelineScrollPercentage) {
        if (generatingBackground == false) { //to avoid bug
            double scrolledLength = timelineScrollPercentage * (timelineWidth - viewportWidth); //(currentPageNumber +3) * timelinePageWidth;
            currentPageNumber = calculateCurrentPage(scrolledLength);
            System.out.println("timelineWidth: " + timelineWidth + "; scrolled: " + scrolledLength + "; CP: " + currentPageNumber);
            if (previousCurrentPageNumber != currentPageNumber) {
                //System.out.println("FIRST PAGE: " + currentPageNumber);
                ScrollDirection direction = currentPageNumber > previousCurrentPageNumber ? ScrollDirection.RIGHT : ScrollDirection.LEFT;
                moveTimelineBackground(direction);
                loadEvents(currentPageNumber, direction);
                previousCurrentPageNumber = currentPageNumber;
            }
            updateEdgeLabels(scrolledLength);
        }
    }

    int previousLabelPageNumber_right = -1;
    int previousLabelPageNumber_left = -1;

    private void updateEdgeLabels(double scrolledLength) {
        if (timelineType.equals("absolute")) {
            double lenghtPage = 0;
            String datePattern = "d MMM";
            if (pageTimeUnit == Calendar.DAY_OF_MONTH) {
                //Each page is a day
                lenghtPage = lenght24hours;
            } else if (pageTimeUnit == Calendar.WEEK_OF_MONTH) {
                lenghtPage = lenght24hours * 7;
                datePattern = "y";
            } else if (pageTimeUnit == Calendar.MONTH) {
                lenghtPage = lenght24hours * 30;
                datePattern = "MMM";
            } else if (pageTimeUnit == Calendar.YEAR) {
                lenghtPage = lenght24hours * 365.25;
                datePattern = "yyyy";
            }

            int leftPageNumber = (int) ((scrolledLength - offSetStartingTimeGUI) / lenghtPage);
            int rightPageNumber = (int) ((scrolledLength - offSetStartingTimeGUI + viewportWidth) / lenghtPage);
            //System.out.println("left: "+leftPageNumber+"; right: "+rightPageNumber+"; scrll:"+scrolledLength+" vp: "+viewportWidth);

            if (scrolledLength < 50) {
                parentController.setTimeLabelLeft("");
                previousLabelPageNumber_left = -1;
            } else {
                if (previousLabelPageNumber_left != leftPageNumber) {
                    previousLabelPageNumber_left = leftPageNumber;
                    Calendar c = new GregorianCalendar(startTimelineDate.get(Calendar.YEAR), startTimelineDate.get(Calendar.MONTH), startTimelineDate.get(Calendar.DAY_OF_MONTH));
                    c.add(pageTimeUnit, leftPageNumber);
                    parentController.setTimeLabelLeft(new SimpleDateFormat(datePattern, Locale.ENGLISH).format(c.getTime()));
                }
            }

            //if(previousLabelPageNumber!=currentLabelPageNumber) {
            //previousLabelPageNumber = currentLabelPageNumber;
            //update right and left labels
            //if (scrolledLength+viewportWidth > currentLabelPageNumber * timelinePageWidth) {
            if (previousLabelPageNumber_right != rightPageNumber) {
                Calendar c = new GregorianCalendar(startTimelineDate.get(Calendar.YEAR), startTimelineDate.get(Calendar.MONTH), startTimelineDate.get(Calendar.DAY_OF_MONTH));
                c.add(pageTimeUnit, rightPageNumber);
                parentController.setTimeLabelRight(new SimpleDateFormat(datePattern, Locale.ENGLISH).format(c.getTime()));
            }
            //}
        }
    }

    private double convertSecondsToPixels(long seconds) {
        return (lenght24hours / 86400) * seconds;
    }

    private void moveTimelineBackground(ScrollDirection direction) {
        if (generatingBackground == false) {
            generatingBackground = true;
            //boolean ignore = false;
            var pagenumb = currentPageNumber;
            if(timelineType.equals("absolute")) {
                if (currentPageNumber > 1){ //TODO: check if this is important: && direction == ScrollDirection.RIGHT) {
                    pagenumb = currentPageNumber - 1;
                }
            }else {
                //if(currentPageNumber<3 && direction == ScrollDirection.RIGHT) {
                //    pagenumb = 0;
                //}
                //if(direction == ScrollDirection.RIGHT) {
                    if (currentPageNumber < 3) {
                        pagenumb = 0;//currentPageNumber - 1;
                    }
                //} else if(direction == ScrollDirection.LEFT) {
                //    ignore = true;
                //}
            }

            //if(ignore==false) {
                double newSpacerWidth = 0;
                if (timelineType.equals("absolute")) {
                    Calendar calendar = GregorianCalendar.getInstance(); // creates a new calendar instance
                    calendar.setTime(startTimelineDate.getTime());
                    calendar.add(Calendar.DAY_OF_MONTH, pagenumb); // for hour scale, each page is a day
                    newSpacerWidth = convertSecondsToPixels(calendar.toInstant().getEpochSecond() - timelineStartSeconds);
                    //TODO: we have a problem with the pusher in the day scale
                    System.out.println("TL start: " + timelineStartSeconds + "; PS: " + calendar.toInstant().getEpochSecond());
                } else {
                    //System.out.println("int page width" + intPageWidth + "; page num: " + pagenumb);
                    if (currentPageNumber > 2) {
                        newSpacerWidth = intPageWidth * (currentPageNumber - 2);
                    }
                    //newSpacerWidth = newSpacerWidth > 0 ? newSpacerWidth : 0;

                    if (newSpacerWidth > 0) {
                        pagenumb -= 2;
                        //System.out.println("page adjusted, start scale: "+pagenumb);
                    }
                }
                leftSpacer.setMinWidth(newSpacerWidth);
                leftSpacer.setPrefWidth(newSpacerWidth);
                leftSpacer.setMaxWidth(newSpacerWidth);
                System.out.println("timelineWidth: " + timelineWidth + "; pusher lemgth: "+newSpacerWidth+" CP: " + currentPageNumber);
            //}

            if (pageTimeUnit == Calendar.WEEK_OF_MONTH || pageTimeUnit == Calendar.MONTH) {
                timelineBackgroundHolder.getChildren().removeAll(rulerPages);
            }


                for (int i = 0; i < rulerPages.length; i++) {
                    if (pageTimeUnit == Calendar.WEEK_OF_MONTH || pageTimeUnit == Calendar.MONTH) {
                        rulerPages[i] = createTimelineBackgroundPage(null, pagenumb);
                    }else {
                        //repurposing
                        createTimelineBackgroundPage(rulerPages[i], pagenumb);
                    }
                    //} else {
                    //    rulerPages[i] = createTimelineBackgroundPage(null, pagenumb);
                    //}
                    pagenumb++;
                }


            //System.out.println("NEW WIDTH: " + newSpacerWidth);
            //(currentPageNumber - 1) * (timelinePageWidth + (spaceBetweenMarkers / 2)); //leftSpacer.getWidth() + backgroundPages[0].getWidth();
            if (pageTimeUnit == Calendar.WEEK_OF_MONTH || pageTimeUnit == Calendar.MONTH) {
                timelineBackgroundHolder.getChildren().addAll(rulerPages);
            }


            generatingBackground = false;

        }
    }

    private void resetOccupiedEventSlots(ScrollDirection direction, double newValue) {
        if (direction == ScrollDirection.RIGHT) {
            //we reset the occupied slots on the left, so when the user goes back the program know we have
            //space there
            for (int i = 0; i < occupiedEventSlots_leftEdge.length; i++) {
                occupiedEventSlots_leftEdge[i] = newValue;
            }
        } else {
            //we reset the occupied slots on the right, so when the user goes forward the program know we have
            //space there
            for (int i = 0; i < occupiedEventSlots_rightEdge.length; i++) {
                occupiedEventSlots_rightEdge[i] = newValue;
            }
        }
    }

    private GridPane createTimelineBackgroundPage(GridPane pageToRepurpose, int page) {
        GridPane timelinePage;
        if (pageToRepurpose == null) {
            System.out.println("CREATING PAGE " + page + " of the scale");
            timelinePage = new GridPane();
        } else {
            System.out.println("REPURPOSING PAGE " + page + " of the scale");
            timelinePage = pageToRepurpose;
        }

        //Make it start at midnight (laready done in setTimeline)
        //calendar.set(Calendar.HOUR_OF_DAY,0);
        //calendar.set(Calendar.MINUTE,0);

        int numberOfBigMarkersPerPage = 0;
        int numberOfMediumMarkerPerPage = 0;
        int numberOfSmallMarkerPerPage = 0;
        int bigMarkerFromXandX = 2;

        double spaceBetweenBigMarkers = 0.0;
        double minSpaceBetweenMarkers = 0.0;

        double pageWidth = 0.0;
        int starPageInt = 0; //for relative page
        //==== SCALES PRESET ====
        Calendar calendar = null;
        if (timelineType.equals("absolute")) {
            calendar = GregorianCalendar.getInstance(); // creates a new calendar instance
            calendar.setTime(startTimelineDate.getTime());
            if (lenght24hours > 1700.0) {
                pageTimeUnit = Calendar.DAY_OF_MONTH;
                //HOUR SCALE (EACH PAGE IS A DAY)
                numberOfBigMarkersPerPage = 24; //number of hours a day
                //spaceBetweenMarkers = lenght24hours / ((numberOfMarkerPerPage*2));
                spaceBetweenBigMarkers = lenght24hours / numberOfBigMarkersPerPage;
                pageWidth = lenght24hours;
                if (page > 0) {
                    //each page is one day, add a day for each page
                    calendar.add(pageTimeUnit, page);
                }
            } else if (lenght24hours > 200.0 && lenght24hours <= 1700.0) {
                //DAY SCALE (EACH PAGE IS A WEEK)
                numberOfBigMarkersPerPage = 7; //number of days a week
                spaceBetweenBigMarkers = lenght24hours; /// ((numberOfMarkerPerPage*2));
                pageTimeUnit = Calendar.WEEK_OF_MONTH;
                pageWidth = lenght24hours * 7;
                if (page > 0) {
                    //each page is one day, add a day for each page
                    calendar.add(pageTimeUnit, page);
                }
            } else if (lenght24hours > 100.0 && lenght24hours <= 200.0) {
                //DAY SCALE (EACH PAGE IS A Month)
                pageTimeUnit = Calendar.MONTH;
                if (page > 0) {
                    //each page is one day, add a day for each page
                    calendar.add(pageTimeUnit, page);
                }
                numberOfBigMarkersPerPage = calendar.getActualMaximum(Calendar.DAY_OF_MONTH); //number of days in this month
                spaceBetweenBigMarkers = lenght24hours; /// ((numberOfMarkerPerPage*2));
                pageWidth = lenght24hours * numberOfBigMarkersPerPage; // the width depends of the month
            } else if (lenght24hours <= 100.0) {
                pageTimeUnit = Calendar.YEAR;
                if (page > 0) {
                    //each page is one year, add a year for each page
                    calendar.add(pageTimeUnit, page);
                }
                numberOfBigMarkersPerPage = 12;
                spaceBetweenBigMarkers = lenght24hours * 30; //30 days in average?
                pageWidth = numberOfBigMarkersPerPage * spaceBetweenBigMarkers;
            }
        } else {
            //each page as 30 integers
            starPageInt = startTimelineInt;
            pageWidth = intPageWidth;
            spaceBetweenBigMarkers = pageWidth / intPerPage;
            numberOfBigMarkersPerPage = intPerPage;
            if (page > 0) {
                //each page is one year, add a year for each page
                starPageInt = page * intPerPage + startTimelineInt;
            }
        }

        //double bigMarkersDensity = numberOfBigMarkersPerPage / pageWidth;
        double spaceBetweenMediumMarkers = 0.0;
        double spaceBetweenSmallMarkers = 0.0;
        int mediumInBetween = 0;
        int smallInBetween = 0;
        int totalNumberMarkers = 0;
        if (spaceBetweenBigMarkers > 200) {
            //System.out.println("SHOW SMALL MARKERS space betw big markers "+spaceBetweenBigMarkers);
            //numberOfMediumMarkerPerPage = (int) (spaceBetweenBigMarkers / 100.0);
            mediumInBetween = (int) (spaceBetweenBigMarkers / 100.0);
            //if(mediumInBetween%2!=0) {
            //    mediumInBetween--;
            //}
            smallInBetween = (int) (spaceBetweenBigMarkers / 10.0) - mediumInBetween;
            //smallInBetween must be divisible by mediumInBetween+1
            if (smallInBetween % (mediumInBetween + 1) != 0) {
                smallInBetween = closestDivisibleNumber(smallInBetween, (mediumInBetween + 1)); //(int) smallInBetween / (mediumInBetween+1);
            }
            spaceBetweenMediumMarkers = 100.0; //JUST A POSITIVE NUMBER
            spaceBetweenSmallMarkers = 10.0; //JUST A POSITIVE NUMBER
            numberOfMediumMarkerPerPage = mediumInBetween * numberOfBigMarkersPerPage;
            numberOfSmallMarkerPerPage = (smallInBetween * numberOfBigMarkersPerPage) - numberOfMediumMarkerPerPage;
            totalNumberMarkers = (numberOfBigMarkersPerPage + numberOfMediumMarkerPerPage + numberOfSmallMarkerPerPage);
        } else if (spaceBetweenBigMarkers > 50) {
            //System.out.println("SHOW MEDIUM MARKERS:  space betw big markers " + spaceBetweenBigMarkers);
            mediumInBetween = (int) (spaceBetweenBigMarkers / 50.0);
            numberOfMediumMarkerPerPage = mediumInBetween * numberOfBigMarkersPerPage;
            totalNumberMarkers = numberOfMediumMarkerPerPage + numberOfBigMarkersPerPage;
            spaceBetweenMediumMarkers = 10.0; //JUST A POSITIVE NUMBER //spaceBetweenBigMarkers / ((numberOfBigMarkersPerPage/numberOfMediumMarkerPerPage)+1);
            spaceBetweenSmallMarkers = 0.0;
        } else {
            //show only big markers
            totalNumberMarkers = numberOfBigMarkersPerPage;
        }
        //System.out.println("Big: " + numberOfBigMarkersPerPage + "; Medium: " + mediumInBetween + "; Small: " + smallInBetween);
        minSpaceBetweenMarkers = pageWidth / totalNumberMarkers;

        timelinePage.setMinWidth(GridPane.USE_COMPUTED_SIZE);
        timelinePage.setPrefWidth(GridPane.USE_COMPUTED_SIZE);
        timelinePage.setMaxWidth(GridPane.USE_COMPUTED_SIZE);
        //timelinePage.setStyle("-fx-background-color: aqua");
        //Create a brand new page
        if (pageToRepurpose == null || pageTimeUnit == Calendar.WEEK_OF_MONTH || pageTimeUnit == Calendar.MONTH) {
            timelinePage.setHgap(0);
            timelinePage.setVgap(0);
            timelinePage.setSnapToPixel(false);
            //define width
            for (int i = 0; i < totalNumberMarkers; i++) {
                ColumnConstraints column;
                //if(i==0 || i==(numberOfMarkerPerPage*2+1)) {
                //     column = new ColumnConstraints(spaceBetweenMarkers/2);
                //} else {
                column = new ColumnConstraints();
                column.setMaxWidth(minSpaceBetweenMarkers);
                column.setMinWidth(minSpaceBetweenMarkers);
                column.setPrefWidth(minSpaceBetweenMarkers);
                //}
                timelinePage.getColumnConstraints().add(column);
            }
            //define height
            for (int r = 0; r < 3; r++) {
                timelinePage.getRowConstraints().add(new RowConstraints(10));
            }

            List<Node> timeline_elements = new ArrayList<>();

            int hour = 0;
            int mainLabelID = 0;
            int secondaryLabelID = 0;
            for (int i = 0; i < totalNumberMarkers; i++) {
                Line lnTop;
                Line lnBottom;
                if ((i + 1) % (mediumInBetween + smallInBetween + 1) == 0) {
                    //big marker
                    double bigMarkerLine = 6.0;
                    lnTop = new Line(0.0, 0.0, 0.0, bigMarkerLine);
                    lnTop.setStrokeWidth(2);

                    lnBottom = new Line(0.0, 0.0, 0.0, bigMarkerLine);
                    lnBottom.setStrokeWidth(2);

                    String mainLabel = "";
                    String secondaryLabel = "";
                    if (timelineType.equals("absolute")) {
                        if (pageTimeUnit == Calendar.DAY_OF_MONTH) {
                            mainLabel += hour;
                            if (hour < 10) {
                                mainLabel = "0" + mainLabel;
                            }
                            mainLabel = mainLabel + ":00";
                            if (mainLabel.equals("00:00")) {
                                secondaryLabel = calendar.get(Calendar.DAY_OF_MONTH) + " / " + (calendar.get(Calendar.MONTH) + 1);
                            }
                            hour++;
                        } else if (pageTimeUnit == Calendar.WEEK_OF_MONTH) {
                            //each page is a week
                            calendar.add(Calendar.DAY_OF_WEEK, 1);
                            mainLabel = new SimpleDateFormat("dd", Locale.ENGLISH).format(calendar.getTime());
                            secondaryLabel = new SimpleDateFormat("w, MMM", Locale.ENGLISH).format(calendar.getTime());
                        } else if (pageTimeUnit == Calendar.MONTH) {
                            //each page is a week or a month
                            calendar.add(Calendar.DAY_OF_MONTH, 1);
                            mainLabel = new SimpleDateFormat("dd", Locale.ENGLISH).format(calendar.getTime());
                            secondaryLabel = new SimpleDateFormat("MMM", Locale.ENGLISH).format(calendar.getTime());
                        } else if (pageTimeUnit == Calendar.YEAR) {
                            //each page is a year
                            calendar.add(Calendar.MONTH, 1);
                            mainLabel = new SimpleDateFormat("MMM", Locale.ENGLISH).format(calendar.getTime());
                            secondaryLabel = new SimpleDateFormat("YYYY", Locale.ENGLISH).format(calendar.getTime());
                        }
                    } else {
                        mainLabel = "" + starPageInt;
                        starPageInt++;
                    }

                    Label text = new Label(mainLabel);
                    text.setId("mainLabel_" + mainLabelID);
                    text.setStyle("-fx-text-fill: #F7F7F7");
                    mainLabelID++;

                    double labelMinWidth = 50;
                    int secondary_i = i + 1;
                    int numColumns = 1;
                    if (minSpaceBetweenMarkers < labelMinWidth) {
                        numColumns = (int) (labelMinWidth / minSpaceBetweenMarkers);
                        if (numColumns % 2 == 0) { //if is not even we add one
                            numColumns++;
                        }
                        if (i - (numColumns / 2) >= 0) {
                            timelinePage.setConstraints(text, i - (numColumns / 2), 1);
                        } else {
                            timelinePage.setConstraints(text, 0, 1);
                        }

                        GridPane.setColumnSpan(text, numColumns);
                        secondary_i = i + (numColumns / 2) + 1;
                        if (secondary_i < 0) {
                            secondary_i = 0;
                        }
                        //timelinePage
                    } else {
                        timelinePage.setConstraints(text, i, 1);
                    }

                    //if(secondaryLabel.equals("")==false) {
                    Label secondarylabel = new Label(secondaryLabel);
                    secondarylabel.setId("secondaryLabel_" + secondaryLabelID);
                    secondaryLabelID++;
                    secondarylabel.setStyle("-fx-font-size: 10; -fx-text-fill: #F7F7F7");
                    if (i - 1 >= 0) {
                        timelinePage.setConstraints(secondarylabel, secondary_i, 1);
                        GridPane.setColumnSpan(secondarylabel, numColumns);
                        timelinePage.setHalignment(secondarylabel, HPos.LEFT); // To align horizontally in the cell
                        timelinePage.setValignment(secondarylabel, VPos.CENTER);// To align vertically in the cell
                        timeline_elements.add(secondarylabel);
                    }
                    // }

                    //CREATE SECONDARY LABEL (with day date)
                    /*if (scale.equals("hour") || scale.equals("Hours")) {
                        hour++;
                        calendar.add(Calendar.HOUR, 1);
                        if (day != null) {
                            Label secondarylabel = new Label(day);
                            secondarylabel.setId("secondaryLabel_" + secondaryLabelID);
                            secondaryLabelID++;
                            secondarylabel.setStyle("-fx-font-size: 10; -fx-text-fill: #F7F7F7");
                            if(i-1>=0) {
                                timelinePage.setConstraints(secondarylabel, secondary_i, 1);
                                GridPane.setColumnSpan(secondarylabel, numColumns);
                                timelinePage.setHalignment(secondarylabel, HPos.LEFT); // To align horizontally in the cell
                                timelinePage.setValignment(secondarylabel, VPos.CENTER);// To align vertically in the cell
                                timeline_elements.add(secondarylabel);
                            }
                        }
                    }*/

                    timeline_elements.add(text);
                    timelinePage.setHalignment(text, HPos.CENTER); // To align horizontally in the cell
                    timelinePage.setValignment(text, VPos.CENTER);// To align vertically in the cell
                    lnTop.setStroke(Color.web("#F7F7F7"));
                    lnBottom.setStroke(Color.web("#F7F7F7"));
                    timelinePage.setConstraints(lnTop, i, 0);
                    timelinePage.setHalignment(lnTop, HPos.CENTER); // To align horizontally in the cell
                    timelinePage.setValignment(lnTop, VPos.TOP);// To align vertically in the cell
                    timeline_elements.add(lnTop);
                    timelinePage.setConstraints(lnBottom, i, 2);
                    timelinePage.setHalignment(lnBottom, HPos.CENTER); // To align horizontally in the cell
                    timelinePage.setValignment(lnBottom, VPos.BOTTOM);// To align vertically in the cell
                    timeline_elements.add(lnBottom);
                } else if (spaceBetweenMediumMarkers > 0 && (i + 1) % ((smallInBetween) / (mediumInBetween + 1) + 1) == 0) {
                    //medium marker
                    double mediumMarkerHeight = 7.0;
                    lnTop = new Line(0.0, 0.0, 0.0, mediumMarkerHeight);
                    lnTop.setStrokeWidth(1);
                    lnBottom = new Line(0.0, 0.0, 0.0, mediumMarkerHeight);
                    lnBottom.setStrokeWidth(1);
                    lnTop.setStroke(Color.rgb(255, 255, 255, 0.7));
                    lnBottom.setStroke(Color.rgb(255, 255, 255, 0.7));
                    timelinePage.setConstraints(lnTop, i, 0);
                    timelinePage.setHalignment(lnTop, HPos.CENTER); // To align horizontally in the cell
                    timelinePage.setValignment(lnTop, VPos.TOP);// To align vertically in the cell
                    timeline_elements.add(lnTop);
                    timelinePage.setConstraints(lnBottom, i, 2);
                    timelinePage.setHalignment(lnBottom, HPos.CENTER); // To align horizontally in the cell
                    timelinePage.setValignment(lnBottom, VPos.BOTTOM);// To align vertically in the cell
                    timeline_elements.add(lnBottom);
                } else if (spaceBetweenSmallMarkers > 0) {
                    lnTop = new Line(0.0, 0.0, 0.0, 3.0);
                    lnTop.setStrokeWidth(1);
                    lnBottom = new Line(0.0, 0.0, 0.0, 3.0);
                    lnBottom.setStrokeWidth(1);
                    lnTop.setStroke(Color.rgb(255, 255, 255, 0.3));
                    lnBottom.setStroke(Color.rgb(255, 255, 255, 0.3));
                    timelinePage.setConstraints(lnTop, i, 0);
                    timelinePage.setHalignment(lnTop, HPos.CENTER); // To align horizontally in the cell
                    timelinePage.setValignment(lnTop, VPos.TOP);// To align vertically in the cell
                    timeline_elements.add(lnTop);
                    timelinePage.setConstraints(lnBottom, i, 2);
                    timelinePage.setHalignment(lnBottom, HPos.CENTER); // To align horizontally in the cell
                    timelinePage.setValignment(lnBottom, VPos.BOTTOM);// To align vertically in the cell
                    timeline_elements.add(lnBottom);
                }
                //spaceProcessed+=minSpaceBetweenMarkers;
            }

            timelinePage.getChildren().addAll(timeline_elements);
            //add space at the end
            //timelineBackgroundHolder.setMargin(timelinePage,new Insets(0,spaceBetweenMarkers/2,0,0));
        } else {
            //check if width is ok
            String mainLabel = "";
            String secondaryLabel = "";
            if (timelineType.equals("absolute")) {
                if (pageTimeUnit == Calendar.DAY_OF_MONTH && calendar != null) {
                    secondaryLabel = calendar.get(Calendar.DAY_OF_MONTH) + " / " + (calendar.get(Calendar.MONTH) + 1);
                    //in the hour scale we just need to change the day, everything else remains the same
                    //} else if(pageTimeUnit==Calendar.WEEK_OF_MONTH || pageTimeUnit==Calendar.MONTH) {
                    //RECREATE PAGE FROM STRATCH
                } else if (pageTimeUnit == Calendar.YEAR && calendar != null) {
                    //each page is a year
                    //calendar.add(Calendar.MONTH,1);
                    //mainLabel = new SimpleDateFormat("MMM",Locale.ENGLISH).format(calendar.getTime());
                    secondaryLabel = new SimpleDateFormat("YYYY", Locale.ENGLISH).format(calendar.getTime());
                }
            } else {
                for (int l = 0; l < numberOfBigMarkersPerPage; l++) {
                    Label label = (Label) timelinePage.lookup("#mainLabel_" + l);
                    String mLabel = "";
                    if(label!=null) {
                        mLabel = "" + starPageInt;
                        label.setText(mLabel);
                        starPageInt++;
                    }
                }
                //TODO: TRY TO REPOURPOSE RELATIVE TIMESCALES
                //ATENTION, if we recreate all the timepage we need to remove and add from the timeline
            }


            Label secLabel = (Label) pageToRepurpose.lookup("#secondaryLabel_0");
            secLabel.setText(secondaryLabel);


            /*if(scale.equals("hour") || scale.equals("Hours")) {
                //change the labels of the previously created page
                String day = calendar.get(Calendar.DAY_OF_MONTH) + " / " + (calendar.get(Calendar.MONTH) + 1);
                //in the hour scale we just need to change the date, everything else remains the same
                Label secLabel = (Label) pageToRepurpose.lookup("#secondaryLabel_0");
                secLabel.setText(day);
            }*/
        }
        return timelinePage;
    }

    //calculate startInt and endInt
    private int calculateEventSearchInt(ScrollDirection direction, String endPoint) {
        //if it's a relative timeline
        if (direction == ScrollDirection.RIGHT) {
            //load events of the next day
            if (endPoint.equals("from")) {
                return timeline.getStartInt() + ((currentPageNumber + 3) * intPerPage);
            } else {
                return timeline.getStartInt() + ((currentPageNumber + 4) * intPerPage);
            }
        } else if (direction == ScrollDirection.NONE) {
            if (endPoint.equals("from")) {
                return timeline.getStartInt();
            } else {
                return timeline.getStartInt() + (4 * intPerPage);
            }
        }
        return 0;
    }

    //calculate startDate and endDate
    //endPoint = "from" or "to"
    private Calendar calculateEventSearchDate(ScrollDirection direction, String endPoint) {
        if (timelineType.equals("absolute") || timelineType.equals("semi")) {
            Calendar result = new GregorianCalendar();
            result.setTime(timeline.getStartDate()); //add timeline start
            int pTimeUnit = pageTimeUnit;
            int int_pPage = 1;
            if (timelineType.equals("semi")) {
                if (timeline.getTimeUnit().equals("second") || timeline.getTimeUnit().equals("Seconds")) {
                    pTimeUnit = Calendar.SECOND;
                } else if (timeline.getTimeUnit().equals("minute") || timeline.getTimeUnit().equals("Minutes")) {
                    pTimeUnit = Calendar.MINUTE;
                } else if (timeline.getTimeUnit().equals("year") || timeline.getTimeUnit().equals("Years") || timeline.getTimeUnit().equals("decade") || timeline.getTimeUnit().equals("Decades") || timeline.getTimeUnit().equals("century") || timeline.getTimeUnit().equals("Centuries")) {
                    pTimeUnit = Calendar.YEAR;
                }
                int_pPage = intPerPage;
            }

            if (direction == ScrollDirection.RIGHT) {
                //load events of the next day
                if (endPoint.equals("from")) {
                    result.add(pTimeUnit, (currentPageNumber + 3) * intPerPage);
                } else {
                    result.add(pTimeUnit, (currentPageNumber + 4) * intPerPage);
                }
                return result;
            } else if (direction == ScrollDirection.NONE) {
                //when the timeline is loaded
                //result.add(semiUnit, 4 * intPerPage);
                if (endPoint.equals("from")) {
                    //result.add(pTimeUnit, (currentPageNumber + 3) * intPerPage);
                } else {
                    result.add(pTimeUnit, 4 * intPerPage);
                }
                return result;
            }
        }
        return null;
    }

    private List<Event> getEvents(int from, int to) {
        List<Event> resEvent = new ArrayList<>();
        try {
            resEvent = this.getTimeline().getEventsBetween(from, to);
        } catch (Exception e) {
            System.err.println("Error loading events");
            System.err.println(e.getMessage());
        }
        return resEvent;
    }

    private List<Event> getEvents(Calendar from, Calendar to) {
        List<Event> resEvent = new ArrayList<>();
        try {
            resEvent = this.getTimeline().getEventsBetween(calendarToLocalDateTime(from), calendarToLocalDateTime(to));
        } catch (Exception e) {
            System.err.println("Error loading events");
            System.err.println(e.getMessage());
        }
        return resEvent;
    }

    private void loadEvents(int currentPageNumber, ScrollDirection direction) {
        if (busy == false && (direction == ScrollDirection.NONE || (direction == ScrollDirection.RIGHT && currentPageNumber>lastPageLoadedEvents))) {
            if(currentPageNumber==0) {
                lastPageLoadedEvents = 3;
            } else {
                lastPageLoadedEvents = currentPageNumber;
            }

            //absolute or semi timelines
            Calendar from = calculateEventSearchDate(direction, "from");
            Calendar to = calculateEventSearchDate(direction, "to");
            //relative timelines
            int fromInt = calculateEventSearchInt(direction, "from");
            int toInt = calculateEventSearchInt(direction, "to");

            TimelineController timelineController = this;
            Task<ArrayList<EventThumbnail>> loadEventsTask = new Task<ArrayList<EventThumbnail>>() {
                @Override
                public ArrayList<EventThumbnail> call() {
                    timelineController.setBusy(true);
                    ArrayList<EventThumbnail> result = new ArrayList<>();

                    List<Event> resEvent;
                    if (timelineType.equals("relative")) {
                        resEvent = getEvents(fromInt, toInt);
                    } else {
                        resEvent = getEvents(from, to);
                    }
                    if (resEvent != null) {
                        //System.out.println("EVENTS FOUND: " + resEvent.size());
                        for (Event event : resEvent) {
                            long timestampSeconds;
                            if (event.getStartDate() != null) {
                                timestampSeconds = event.getStartDate().atZone(ZoneId.systemDefault()).toEpochSecond();
                            } else {
                                timestampSeconds = event.getStartInt();
                            }
                            //double numberOfSecondsSinceStartOfTimeline = timestampSeconds - timelineController.getTimelineStartSeconds();
                            double horzPos = calculateHorzPos(timestampSeconds); //((timelineController.lenght24hours / 86400.0) * numberOfSecondsSinceStartOfTimeline) - 3.0 + timelineController.getOffSetStartingTimeGUI(); // + offSetStartingTimeGUI - 3.0;

                            EventThumbnail eventThumbnail = new EventThumbnail(event, horzPos, timelineController.chooseVerticalSlot(horzPos, 234.0, direction), timelineController);
                            eventThumbnail.createView(timelineController.getTimeRatio());
                            result.add(eventThumbnail);
                        }
                    }
                    return result;
                }
            };

            loadEventsTask.setOnSucceeded(e -> {
                timelineController.getActiveEventThumbnails().addAll(loadEventsTask.getValue());
                timelineController.addAllEventGUI(loadEventsTask.getValue());
                System.out.println("thread complete");
                timelineController.setBusy(false);
            });

            loadEventsTask.setOnFailed(e -> loadEventsTask.getException().printStackTrace());

            if (eventsLoaderThread != null) {
                eventsLoaderThread.interrupt();
            }
            eventsLoaderThread = new Thread(loadEventsTask);
            eventsLoaderThread.start();
        }
    }

    public double calculateHorzPos(long timestampSeconds) {
        if (timelineType.equals("absolute")) {
            double numberOfSecondsSinceStartOfTimeline = timestampSeconds - timelineStartSeconds;
            return ((lenght24hours / 86400.0) * numberOfSecondsSinceStartOfTimeline) - 3.0 + offSetStartingTimeGUI;
        } else if (timelineType.equals("semi")) {
            double numberOfSecondsSinceStartOfTimeline = timestampSeconds - timelineStartSeconds;
            double lengthPerUnit;
            if (timeline.getTimeUnit().equals("second") || timeline.getTimeUnit().equals("Seconds")) {
                lengthPerUnit = (intPageWidth / intPerPage) * numberOfSecondsSinceStartOfTimeline;
            } else if (timeline.getTimeUnit().equals("minute") || timeline.getTimeUnit().equals("Minutes")) {
                lengthPerUnit = (intPageWidth / intPerPage) * (numberOfSecondsSinceStartOfTimeline / 60);
            } else if (timeline.getTimeUnit().equals("year") || timeline.getTimeUnit().equals("Years") || timeline.getTimeUnit().equals("decade") || timeline.getTimeUnit().equals("Decades") || timeline.getTimeUnit().equals("century") || timeline.getTimeUnit().equals("Centuries")) {
                lengthPerUnit = (intPageWidth / intPerPage) * (numberOfSecondsSinceStartOfTimeline / 31557600);
            } else {
                lengthPerUnit = 0;
                System.err.println("ERROR CALCULATING HORZ POS");
            }
            return lengthPerUnit - 3.0 + offSetStartingTimeGUI;
        } else if (timelineType.equals("relative")) {
            //timestampSeconds => int position
            return ((intPageWidth / intPerPage) * timestampSeconds) - 3.0 + offSetStartingTimeGUI;
        } else {
            System.err.println("ERROR CALCULATING HORZ POS");
            return 0;
        }
    }

    public void addAllEventGUI(ArrayList<EventThumbnail> eventThumbnails) {
        TimelineContainer.getChildren().addAll(eventThumbnails.stream().map(eventThumbnail -> {
            TimelineContainer.setAlignment(eventThumbnail.getView(), Pos.CENTER_LEFT);
            return eventThumbnail.getView();
        }).collect(Collectors.toCollection(ArrayList::new)));
    }

    /////// VERTICAL POSITION /////
    // 0
    // 1
    // 2
    // 3
    // ---------------------------
    // 4
    // 5
    // 6
    // 7
    //////////////////////////////

    private int chooseVerticalSlot(double horzPos, double thumbnailWidth, ScrollDirection direction) {
        //order of vertical preference
        // 2 => 3 => 1 => 5 => 4 => 6 => 0 => 7
        int[] prefOrder = {2, 3, 1, 5, 4, 6, 0, 7};
        double[] memorySlots = (direction == ScrollDirection.RIGHT || direction == ScrollDirection.NONE) ? occupiedEventSlots_rightEdge : occupiedEventSlots_leftEdge;

        for (int i : prefOrder) {
            if ((direction == ScrollDirection.RIGHT || direction == ScrollDirection.NONE) && horzPos > memorySlots[i]) {
                memorySlots[i] = horzPos + thumbnailWidth;
                return i;
            } else if (direction == ScrollDirection.LEFT && (horzPos + thumbnailWidth) < memorySlots[i]) {
                memorySlots[i] = horzPos;
                return i;
            }
        }
        System.err.println("NO VERTICAL SPACE FOUND!");
        return 0;
    }

    //delete and remove from GUI events not being seen by the user at the moment
    private void removeEventsOutsideViewport() {

        //TODO: recalculate free vertical space
        //resetOccupiedEventSlots();

        Calendar removeUntilDate = new GregorianCalendar(); //to the left of theview port
        Calendar removeAfterDate = new GregorianCalendar(); //to the right of the viewPort
        removeUntilDate.setTime(timeline.getStartDate());
        removeAfterDate.setTime(timeline.getStartDate());
        if (timeline.getTimeUnit().equals("hour") || timeline.getTimeUnit().equals("Hours")) {
            //each page is a day, we get the last pertinent date
            removeUntilDate.add(Calendar.DAY_OF_MONTH, currentPageNumber);
            removeAfterDate.add(Calendar.DAY_OF_MONTH, currentPageNumber + 4);
        }

        ArrayList<EventThumbnail> eventsThumbsToRemove = new ArrayList<>();

        LocalDateTime removeUntilDate_dt = LocalDateTime.ofInstant(removeUntilDate.toInstant(), ZoneId.systemDefault());
        LocalDateTime removeAfterDate_dt = LocalDateTime.ofInstant(removeAfterDate.toInstant(), ZoneId.systemDefault());

        System.out.println("Remove events until " + removeUntilDate_dt.toString());
        for (EventThumbnail thumb : activeEventThumbnails) {
            //we check first if the end date is before the removeUntilDate (remove if it's the case)
            if (thumb.getEvent().getEndDate() != null && thumb.getEvent().getEndDate().isBefore(removeUntilDate_dt)) {
                System.out.println("removed by last date");
                eventsThumbsToRemove.add(thumb);
            } else if (thumb.getEvent().getStartDate().isBefore(removeUntilDate_dt)) {
                System.out.println("removed by start date");
                eventsThumbsToRemove.add(thumb);
            } else if (thumb.getEvent().getStartDate().isAfter(removeAfterDate_dt)) {
                //if it's on the right side of the view port
                System.out.println("removed by start date -> right edge");
                eventsThumbsToRemove.add(thumb);
            }
        }
        //REMOVE FROM GUI
        TimelineContainer.getChildren().removeAll(eventsThumbsToRemove.stream().map(t -> t.getView()).collect(Collectors.toList()));
        activeEventThumbnails.removeAll(eventsThumbsToRemove);
    }

    ///DEBUG ONLY///
    /*boolean printing = false;
    private void debug(double scrolledLength, String directionIndicator) {
        if(!printing) {
            printing = true;
            System.out.print("======= DEBUG VIEW =======\n"+
                    directionIndicator+""+scrolledLength + "\n"+
                    "Active thumbnails: "+activeEventThumbnails.size() + "/" + totalNumberEvents + "\n"
            );
            printing = false;
        }
    }*/


    /// ==== UTILS ====
    private int getCalendarTimeUnit(double lenght24hours) {
        int pageTimeUnit = 0;
        if (lenght24hours > 1700.0) {
            pageTimeUnit = Calendar.DAY_OF_MONTH;
            //HOUR SCALE (EACH PAGE IS A DAY)
        } else if (lenght24hours > 200.0 && lenght24hours <= 1700.0) {
            //DAY SCALE (EACH PAGE IS A WEEK)
            pageTimeUnit = Calendar.WEEK_OF_MONTH;
        } else if (lenght24hours > 100.0 && lenght24hours <= 200.0) {
            //DAY SCALE (EACH PAGE IS A Month)
            pageTimeUnit = Calendar.MONTH;
        } else if (lenght24hours <= 100.0) {
            pageTimeUnit = Calendar.YEAR;
        }
        return pageTimeUnit;
    }

    public void openEvent(Event event) {
        try {
            FXMLLoader f = new FXMLLoader(getClass().getResource("/Views/Event.fxml"));
            Stage popup = new Stage();
            Parent formView = f.load();
            popup.setScene(new Scene(formView));
            popup.initOwner(Main.getPrimaryStage());
            popup.initModality(Modality.NONE);
            popup.initStyle(StageStyle.TRANSPARENT);
            PopupController pc = f.getController(); //PopupController is a super class common to all forms
            pc.setParentController(parentController);
            System.out.println("804");
            ((EventController) pc).setEvent(event, editMode);
            System.out.println("805");
            pc.setUp(popup, null); //root is null because we don't need to add listeners to inputs
            parentController.turnOpaque();
            popup.showAndWait();
            parentController.turnNotOpaque();
        } catch (Exception e) {
            System.err.println("Problem loding Event fxml");
            System.err.println(e);
        }

    }

    public static LocalDateTime calendarToLocalDateTime(Calendar input) {
        return LocalDateTime.ofInstant(input.toInstant(), ZoneId.systemDefault());
    }

    public static int closestDivisibleNumber(int n, int m) {
        // find the quotient
        int q = n / m;

        // 1st possible closest number
        int n1 = m * q;

        // 2nd possible closest number
        int n2 = (n * m) > 0 ? (m * (q + 1)) : (m * (q - 1));

        // if true, then n1 is the required closest number
        if (Math.abs(n - n1) < Math.abs(n - n2))
            return n1;

        // else n2 is the required closest number
        return n2;
    }

    /**
     * Called to initialize a controller after its root element has been
     * completely processed.
     *
     * @param location  The location used to resolve relative paths for the root object, or
     *                  {@code null} if the location is not known.
     * @param resources The resources used to localize the root object, or {@code null} if
     */
    double minTimelineWidth = 0;
    @Override
    public void initialize(URL location, ResourceBundle resources) {
        //update total width of the timeline when it changes
        timelineBackgroundHolder.widthProperty().addListener((obs, oldVal, newVal) -> {
            if(((double) newVal)>minTimelineWidth) {
                System.out.println("TIMELINE WIDTH: " + newVal);
                minTimelineWidth = (double) newVal;
                this.timelineWidth = minTimelineWidth;
                timelineBackgroundHolder.setMinWidth(minTimelineWidth);
            }
        });
    }


    private enum ScrollDirection {
        NONE,
        RIGHT,
        LEFT
    }

    //SETTTERS AND GETTERS
    void setParentController(MainController mc) {
        this.parentController = mc;
    }

    double getTimeRatio() {
        return timeRatio;
    }

    boolean getBusy() {
        return busy;
    }

    Timeline getTimeline() {
        return timeline;
    }

    double getOffSetStartingTimeGUI() {
        return offSetStartingTimeGUI;
    }

    long getTimelineStartSeconds() {
        return timelineStartSeconds;
    }

    void setBusy(boolean busy) {
        this.busy = busy;
    }

    List<EventThumbnail> getActiveEventThumbnails() {
        return activeEventThumbnails;
    }
}

